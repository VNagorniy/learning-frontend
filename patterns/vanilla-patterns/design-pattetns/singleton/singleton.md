## Оглавление

- [Шаблон Синглтон](#шаблон-синглтон)
  - [Пример с использованием ES2015](#пример-с-использованием-es2015)
  - [Как создать только один экземпляр класса](#как-создать-только-один-экземпляр-класса)
  - [Пример реализации](#пример-реализации)
- [Компромиссы](#компромиссы)
  - [Недостатки использования паттерна](#недостатки-использования-паттерна)
    - Использование обычного объекта
    - Тестирование
    - Скрытие зависимости
    - Глобальное поведение
- [Как использовать Singleton в реальном приложении?](#как-использовать-singleton-в-реальном-приложении)
- [Существуют ли альтернативы шаблону Singleton в JavaScript?](#существуют-ли-альтернативы-шаблону-singleton-в-javascript)

# Шаблон Синглтон

> **Синглтоны** — это классы, экземпляры которых можно создать один раз и получить к ним глобальный доступ. Этот _экземпляр_ может быть общим для всего приложения, что делает синглтоны отличным инструментом для управления глобальным состоянием приложения.

> В настоящее время мы можем создавать несколько экземпляров этого Counter класса.

## Пример с использованием ES2015

Класс Counter будет иметь:

- метод **getInstance**, который возвращает значение экземпляра;
- метод **getCount**, который возвращает текущее значение counter переменной;
- метод **increment**, который увеличивает значение counter на единицу;
- метод **decrement**, который уменьшает значение counter на единицу.

> Однако этот класс не соответствует критериям синглтона! **!!!Синглтон должен быть создан только один раз!!!**

```js
let counter = 0;

class Counter {
	getInstance() {
		return this;
	}

	getCount() {
		return counter;
	}

	increment() {
		return ++counter;
	}

	decrement() {
		return --counter;
	}
}
```

### Как создать только один экземпляр класса

Один из способов гарантировать, что может быть создан только один экземпляр, — создать переменную с именем **instance**. В конструкторе Counter можно установить значение **instance** равное ссылке на экземпляр при создании нового экземпляра. **Мы можем предотвратить создание новых экземпляров, проверяя**, _instance_ имеет ли переменная уже значение. Если это так, экземпляр уже существует. Этого не должно происходить: должна выдаваться ошибка, информирующая пользователя.

```js
let instance;
let counter = 0;

class Counter {
	constructor() {
		if (instance) {
			throw new Error('You can only create one instance!');
		}
		instance = this;
	}

	getInstance() {
		return this;
	}

	getCount() {
		return counter;
	}

	increment() {
		return ++counter;
	}

	decrement() {
		return --counter;
	}
}

const counter1 = new Counter();
const counter2 = new Counter();
// Error: You can only create one instance!

const singletonCounter = Object.freeze(new Counter());
export default singletonCounter;
```

Давайте экспортируем **Counter** экземпляр из counter.js файла. Но перед этим его необходимо заморозить. Этот _Object.freeze_ метод гарантирует, что использующий код не сможет изменить синглтон. Свойства замороженного экземпляра нельзя добавлять или изменять, что снижает риск случайной перезаписи значений синглтона.

### Пример реализации

[Пример реализации паттерна](https://codesandbox.io/embed/lucid-morning-64mr1).

При вызове **increment** метода в одном из файлов **redButton.js** или **blueButton.js** значение свойства **counter** экземпляра _Counter_ обновляется в обоих файлах.

## Компромиссы

Ограничение создания экземпляра всего одним экземпляром потенциально может сэкономить много памяти. Вместо того, чтобы каждый раз выделять память для нового экземпляра, нам достаточно выделить память только для того одного экземпляра, на который ссылается всё приложение.

Однако синглтоны на самом деле считаются антипаттерном и их можно (или… нужно ) избегать в JavaScript.

### Недостатки использования паттерна

**1. Использование обычного объекта**

[Пример реализации паттерна](https://codesandbox.io/embed/competent-moon-rvzrr).

Представим **counter** как объект

Поскольку объекты передаются по ссылке, оба файла **redButton.js** и **blueButton.js** импортируют ссылку на один и тот же **counter** объект. Изменение значения _count_ в любом из этих файлов приведёт к изменению значения в **counter**, которое отображается в обоих файлах.

**2. Тестирование**

Тестирование кода, использующего синглтон, может оказаться непростой задачей. Поскольку мы не можем каждый раз создавать новые экземпляры, все тесты зависят от изменений в глобальном экземпляре предыдущего теста. В этом случае порядок тестов имеет значение, и одно небольшое изменение может привести к сбою всего набора тестов. После тестирования необходимо сбросить весь экземпляр, чтобы сбросить изменения, внесённые тестами.

**3. Скрытие зависимости**

При импорте другого модуля **superCounter.js** в этом случае может быть неочевидно, что модуль импортирует **синглтон**. В других файлах, например, **index.js** в этом случае, мы можем импортировать этот модуль и вызывать его методы.
Таким образом, мы случайно изменяем значения в синглтоне. Это может привести к неожиданному поведению, поскольку несколько экземпляров синглтона могут быть общими для всего приложения, и все они также будут изменены.

[Пример](https://codesandbox.io/embed/sweet-cache-n55vi).

**4. Глобальное поведение**

Экземпляр **Singleton** должен быть доступен для использования во всём приложении. Использование глобальных переменных обычно считается неудачным решением при проектировании. Глобальное загрязнение области видимости может привести к случайной перезаписи значения глобальной переменной, что может привести к множеству непредвиденных последствий.

Обычно одни части кодовой базы изменяют значения в глобальном состоянии, а другие используют эти данные. Порядок выполнения здесь важен: мы не хотим случайно сначала получить данные, когда их (пока) нет! Понимание потока данных при использовании глобального состояния может стать очень сложным по мере роста вашего приложения, когда десятки компонентов зависят друг от друга.

## Как использовать Singleton в реальном приложении?

Синглтоны могут использоваться в различных реальных приложениях. Например, синглтон можно использовать для системы журналирования, чтобы гарантировать наличие только одного экземпляра регистратора в приложении. Синглтон также можно использовать для менеджера конфигураций, чтобы обеспечить глобальную точку доступа к параметрам конфигурации.

## Существуют ли альтернативы шаблону Singleton в JavaScript?

Да, в JavaScript существует несколько альтернатив шаблону Singleton. Одна из них — шаблон Module, позволяющий инкапсулировать закрытые и открытые элементы в одном объекте. Другая альтернатива — шаблон Factory, позволяющий создавать объекты без указания точного класса создаваемого объекта.
